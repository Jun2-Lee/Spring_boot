# MVC 패턴

## 배경

### 너무 많은 역할
하나의 서블릿이나 JSP로직과 뷰 렌더링까지 모두 처리하게 되면, 너무 많은 역할을 하게 되고, 결과적으로 유지보수가 어려워진다.

### 변경의 라이프 사이클
가장 큰 문제는 비즈니스 로직과 뷰 렌더링 사이의 변경 라이프 사이클이 다르다는 점이다. 이렇게 라이프사이클이 다른 부분을 하나의 코드로 관리하는 것은 유지보수에 좋지 않다

### 기능 특화
JSP같은 뷰 템플릿은 화면 렌더링에 최적화 되어 있기 때문에 이 부분의 업무만 담당하는 것이 가장 효과적이다

## MVC - Model View Controller
MVC 패턴은 하나의 서블릿이나, JSP로 처리하던 것을 컨트롤러와 뷰의 영역으로 역할을 나눈 것이다. 웹 애플리케이션은 보통 이 MVC 패턴을 사용한다

- __컨트롤러(Controller)__ : HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다
- __모델(Model)__ : 뷰에 출력할 데이터를 담아둔다. 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주기 때문에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면 렌더링에 집중할 수 있다
- __뷰(View)__ : 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다.

<img width="613" alt="스크린샷 2022-02-22 오후 10 03 02" src="https://user-images.githubusercontent.com/80378041/155137839-8e057034-8f4a-4ff8-b18b-94821972534f.png">

### Controller 메서드
- Servlet에서는 모델의 역할을 request가 한다. `request.setAtrribute`, `request.getAtrribute`를 이용하여 데이터를 보관, 조회할 수 있다
- `RequestDispatcher`클래스의 `dispatcher.foward` 메서드를 이용하여 다른 JSP 파일이나, Servlet을 호출할 수 있다

__jsp 파일을 WEB-INF 디렉토리 밑에 저장하면 JSP 파일을 직접 호출할 수 있다!__

## Servlet MVC 패턴의 한계
MVC 패턴을 적용해서 컨트롤러와 뷰의 역할을 명확하게 구분하였다. 하지만, 코드에 중복이 너무 많고, 필요해보이지 않는 코드들도 많이 보인다

- 중복되는 코드가 많았다
  - JSP를 호출하기 위해 `RequestDispatcher`클래스의 `dispatcher.foward` 메서드를 사용했다
  - 이러한 View로 이동하는 메서드가 계속 중복되었다
- 사용되지 않는 코드들이 있다.
- 공통 처리가 어렵다
  - 기능이 복잡해질수록 컨트롤러에서 공통으로 처리해야 하는 부분이 늘어나는데, 단순히 공통 기능을 메서드로 뽑으면 될 것 같지만, 이것 자체도 중복이다

## 프론트 컨트롤러(Front Controller)
> 이러한 한계를 극복하기 위해 고안되었다. 
> 
> 컨트롤러 호출 전에 먼저 공통 기능을 처리해 주는 기능이 구현된 것이다!(입구를 하나로)
